/*
 * vc4-kms-dsi-sn65dsi8x-overlay.dts
 */

#include <dt-bindings/gpio/gpio.h>
#include <dt-bindings/pinctrl/bcm2835.h>
#include <dt-bindings/interrupt-controller/irq.h>
#include <dt-bindings/clock/bcm2835.h>
#include <dt-bindings/interrupt-controller/arm-gic.h>

/dts-v1/;
/plugin/;

/ {
	compatible = "raspberrypi,4-compute-module", "brcm,bcm2835", "brcm,bcm2711";

	/* PWM0 function */
	fragment@0 {
		target = <&gpio>;
		__overlay__ {
			pwm_pins: pwm_pins {
				brcm,pins = <18>; /* pin 49 */
				brcm,function = <BCM2835_FSEL_ALT5>;
			};

			dsi_lvds_en: dsi_lvds_en {
				brcm,pins = <11>;
				brcm,function = <BCM2835_FSEL_GPIO_OUT>;
			};

			i2c1_pins: i2c1 {
				brcm,pins = <44 45>;
				brcm,function = <BCM2835_FSEL_ALT2>;
				brcm,pull = <BCM2835_PUD_UP>;
			};

			backlight_en: backlight_en {
				brcm,pins = <17>; /* pin 50 */
				brcm,function = <BCM2835_FSEL_GPIO_OUT>;
			};
		};
	};

	fragment@1 {
		target = <&pwm>;
		__overlay__ {
			pinctrl-names = "default";
			pinctrl-0 = <&pwm_pins>;
			assigned-clock-rates = <100000000>;
			status = "okay";
		};
	};

	fragment@2 {
		target-path = "/";
		__overlay__ {
			// Becahse RPI does stupid stuff
			memreserve = <0x30000000 0x10000000>;
			system {
				linux,serial = <0x10000000 0xf00bef2c>;
				linux,revision = <0x00c03140>;
			};

			axi {
				vc_mem {
					reg = <0x3ec00000 0x40000000 0xc0000000>;
				};
			};

			//FANCOM
			backlight_lvds: backlight {
				compatible = "pwm-backlight";
				pwms = <&pwm 0 5000000>; /* 200Hz */
				brightness-levels = <0 1000>;
				num-interpolated-steps = <1000>;
				default-brightness-level = <800>;
				enable-gpios = <&gpio 17 GPIO_ACTIVE_HIGH>;

				power-supply = <&vdd_3v3_reg>;
				status = "okay";
			};

			panel: panel {
				compatible = "panel-lvds";
				status = "okay";

				backlight = <&backlight_lvds>;
				power-supply = <&vdd_3v3_reg>;

				width-mm = <344>;
				height-mm = <194>;

				data-mapping = "vesa-24";

				panel-timing {
					/* clock frequency of 70.93Mhz in the datasheet is for single LVDS channel */
					/* since we use dual LVDS channel, the clock frequency is 2*70.93Mhz */
					/* the bridge driver will correct this */
					/* vc4_dsi.c: however, the dsi parent_rate is 3Ghz and the dsi-divider is fixed to (24/#nr-data lanes) */
					/* (3Ghz / 3)/7 = 142.86Mhz. (142.86Mhz * 24bpp) / 8 = 571Mhz DSI clock */
					/* (3Ghz / 4)/7 = 107.14Mhz. (107.14Mhz * 24bpp) / 8 = 428.57Mhz DSI clock */
					/* minimum required DSI clock is (48bits/(3 lanes * 2)) * 60Mhz = 480Mhz
					/* we'll hence need a 571Mhz capped to 500Mhz DSI clock, with a divider of 8 in the bridge, resulting in 62.5Mhz */
					/* 62.5Mhz * 2 = 125Mhz */
					clock-frequency = <125000000>;

					/* the hactive and porches in the datasheet are for a single LVDS channel */
					/* since we use dual LVDS channel, double everything */
					hactive = <1920>;
					hsync-len = <60>;
					hfront-porch = <60>;
					hback-porch = <60>;

					vactive = <1080>;
					vsync-len = <4>;
					vfront-porch = <3>;
					vback-porch = <3>;

					hsync-active = <0>;
					vsync-active = <0>;
					de-active = <1>;
					pixelclk-active = <1>;
				};

				ports {
					#address-cells = <1>;
					#size-cells = <0>;

					port@0 {
						reg = <0>;
						dual-lvds-odd-pixels;
						panel_in_lvds_channelA: endpoint {
							remote-endpoint = <&bridge_out_channelA>;
						};
					};

					port@1 {
						reg = <1>;
						dual-lvds-even-pixels;
						panel_in_lvds_channelB: endpoint {
							remote-endpoint = <&bridge_out_channelB>;
						};
					};
				};
			};
		};
	};

	fragment@3 {
		target = <&i2c1>;
		__overlay__ {
			#gpio-cells = <2>;
			#address-cells = <1>;
			#size-cells = <0>;
			status = "okay";

			pinctrl-names = "default";
			pinctrl-0 = <&i2c1_pins>;
			clock-frequency = <400000>;

			sn65dsi84@2c {
				compatible = "ti,sn65dsi84";
				reg = <0x2c>;
				enable-gpios = <&gpio 11 GPIO_ACTIVE_HIGH>;

				pinctrl-names = "default";
				pinctrl-0 = <&dsi_lvds_en>;
				status = "okay";

				interrupts = <GIC_SPI 36 IRQ_TYPE_LEVEL_HIGH>;

				ports {
					#address-cells = <1>;
					#size-cells = <0>;

					port@0 {
						reg = <0>;
						bridge_in: endpoint {
							remote-endpoint = <&dsi_out_port>;
							data-lanes = <0 1 2>;
						};
					};

					port@2 {
						reg = <2>;
						bridge_out_channelA: endpoint {
							remote-endpoint = <&panel_in_lvds_channelA>;
						};
					};

					port@3 {
						reg = <3>;
						bridge_out_channelB: endpoint {
							remote-endpoint = <&panel_in_lvds_channelB>;
						};
					};
				};
			};
		};
	};

	fragment@4 {
		target = <&dsi1>;
		__overlay__ {
			#address-cells = <1>;
			#size-cells = <0>;
			status = "okay";
			port {
				dsi_out_port: endpoint {
					remote-endpoint = <&bridge_in>;
					data-lanes = <0 1 2>;
				};
			};
		};
	};

	fragment@5 {
		target = <&i2c0if>;
		__overlay__ {
			status = "okay";
		};
	};

	fragment@6 {
		target = <&i2c0mux>;
		__overlay__ {
			status = "okay";
		};
	};

	fragment@7 { /* Debug port */
		target = <&uart1_pins>;
		__overlay__ {
			brcm,pins = <14 15>; /* pin 51, 55 */
			brcm,function = <BCM2835_FSEL_ALT0>;
			brcm,pull = <0 2>;
		};
	};

	fragment@8 { /* Debug port */
		target = <&uart1>;
		__overlay__ {
			status = "okay";
			pinctrl-names = "default";
			pinctrl-0 = <&uart1_pins>;
		};
	};

	fragment@9 { /* HPAN */
		target = <&uart3_pins>;
		__overlay__ {
			brcm,pins = <4 5 6 7>; /* pin 54, 34, 30, 37 */
			brcm,function = <
				BCM2835_FSEL_GPIO_OUT
				BCM2835_FSEL_GPIO_OUT
				BCM2835_FSEL_GPIO_IN
				BCM2835_FSEL_GPIO_OUT /* Uncertain. */
			>;
			brcm,pull = <0 2 2 0>;
		};
	};

	fragment@10 { /* HPAN */
		target = <&uart3>;
		__overlay__ {
			pinctrl-names = "default";
			pinctrl-0 = <&uart3_pins>;
			status = "okay";
		};
	};

	/* Fixes because RPI does stupid stuff. */
	fragment@1000 {
		target = <&phy1>;
		__overlay__ {
			reg = <0>;
		};
	};

	fragment@1001 {
		target = <&emmc2bus>;
		__overlay__ {
			dma-ranges = <0x00000000 0x00000000 0x00000000 0x00000000 0xfc000000>;
			status = "okay";
		};
	};

	fragment@1002 {
		target-path = "/";
		__overlay__ {
			memory@0 {
				device_type = "memory";
				reg = <0x00000000 0x00000000 0x30000000 0x00000000 0x40000000 0xbc000000>;
			};
		};
	};

	fragment@1003 {
		target = <&dma>;
		__overlay__ {
			brcm,dma-channel-mask = <0x00003000>;
		};
	};

	fragment@1004 { /* nvram */
		target = <&blconfig>;
		__overlay__ {
			reg = <0x00000000 0x3ef5c100 0x00000056>;
			status = "okay";
		};
	};

	fragment@1005 {
		taget = <&pcie0>;
		__overlay__ {
			compatible = "brcm,bcm2711-pcie", "brcm,bcm7445-pcie";
			dma-ranges = <0x02000000 0x00000004 0x00000000 0x00000000 0x00000000 0x00000001 0x00000000>;
		};
	};

	/* cma-overlay.dts */
	fragment@2000 {
		target = <&cma>;
		__overlay__ {
			/*
			 * The default size when using this overlay is 256 MB
			 * and should be kept as is for backwards
			 * compatibility.
			 */
			size = <0x10000000>;
		};
	};

	fragment@3002 {
		target = <&fb>;
		__overlay__  {
			status = "disabled";
		};
	};

	fragment@3003 {
		target = <&pixelvalve0>;
		__overlay__  {
			status = "okay";
		};
	};

	fragment@3004 {
		target = <&pixelvalve1>;
		__overlay__  {
			status = "okay";
		};
	};

	fragment@3005 {
		target = <&pixelvalve2>;
		__overlay__  {
			status = "okay";
		};
	};

	fragment@3006 {
		target = <&hvs>;
		__overlay__  {
			status = "okay";
		};
	};

	fragment@3008 {
		target = <&v3d>;
		__overlay__  {
			status = "okay";
		};
	};

	fragment@3009 {
		target = <&vc4>;
		__overlay__  {
			status = "okay";
		};
	};

	fragment@3010 {
		target = <&clocks>;
		__overlay__  {
			claim-clocks = <
				BCM2835_PLLD_DSI0
				BCM2835_PLLD_DSI1
				BCM2835_PLLH_AUX
				BCM2835_PLLH_PIX
			>;
		};
	};

	fragment@3011 {
		target = <&vec>;
		__overlay__  {
			status = "okay";
		};
	};

	fragment@3012 {
		target = <&txp>;
		__overlay__  {
			status = "disabled"; /* Was "okay" */
		};
	};

	/* dwc2-overlay.dts */
	fragment@4000 {
		target = <&usb>;
		__overlay__ {
			#address-cells = <1>;
			#size-cells = <1>;
			compatible = "brcm,bcm2835-usb";
			dr_mode = "otg";
			g-np-tx-fifo-size = <32>;
			g-rx-fifo-size = <558>;
			g-tx-fifo-size = <512 512 512 512 512 256 256>;
			status = "okay";
		};
	};

	/* disable-bt-overlay.dts */
	fragment@5000 {
		target = <&uart0>;
		__overlay__ {
			pinctrl-names = "default";
			pinctrl-0 = <&uart0_pins>;
			status = "okay";
		};
	};

	fragment@5001 {
		target = <&bt>;
		__overlay__ {
			status = "disabled";
		};
	};

	fragment@5002 {
		target = <&uart0_pins>;
		__overlay__ {
			brcm,pins;
			brcm,function;
			brcm,pull;
		};
	};

	fragment@5003 {
		target = <&bt_pins>;
		__overlay__ {
			brcm,pins;
			brcm,function;
			brcm,pull;
		};
	};

	fragment@5004 {
		target-path = "/aliases";
		__overlay__ {
			serial0 = "/soc/serial@7e201000";
			serial1 = "/soc/serial@7e215040";
		};
	};

	__overrides__ {

		/* Because RPI does stupid stuff. */
		i2c_arm_baudrate = [00 00 00 35 63 6c 6f 63 6b 2d 66 72 65 71 75 65 6e 63 79 3a 30 00];
		i2c_baudrate = [00 00 00 35 63 6c 6f 63 6b 2d 66 72 65 71 75 65 6e 63 79 3a 30 00];
		i2c_arm = [00 00 00 35 73 74 61 74 75 73 00];
		i2c = [00 00 00 35 73 74 61 74 75 73 00];
		i2c_vc_baudrate = [00 00 00 10 63 6c 6f 63 6b 2d 66 72 65 71 75 65 6e 63 79 3a 30 00];
		i2c_vc = [00 00 00 10 73 74 61 74 75 73 00 00 00 00 34 73 74 61 74 75 73 00];

		/* cma-overlay.dts */
		cma-512 = <&cma>,"size:0=",<0x20000000>;
		cma-448 = <&cma>,"size:0=",<0x1c000000>;
		cma-384 = <&cma>,"size:0=",<0x18000000>;
		cma-320 = <&cma>,"size:0=",<0x14000000>;
		cma-256 = <&cma>,"size:0=",<0x10000000>;
		cma-192 = <&cma>,"size:0=",<0xC000000>;
		cma-128 = <&cma>,"size:0=",<0x8000000>;
		cma-96  = <&cma>,"size:0=",<0x6000000>;
		cma-64  = <&cma>,"size:0=",<0x4000000>;
		cma-size = <&cma>,"size:0"; /* in bytes, 4MB aligned */
		cma-default = <0>,"-0";

		/* vc4-kms-v3d.dts */
		audio   = <0>,"!13", <0>,"=14";
		noaudio = <0>,"=13", <0>,"!14";
		nocomposite = <0>, "!11";

		/* dwc2-overlay.dts */
		dr_mode = <&usb>, "dr_mode";
		g-np-tx-fifo-size = <&usb>,"g-np-tx-fifo-size:0";
		g-rx-fifo-size = <&usb>,"g-rx-fifo-size:0";
	};
};
